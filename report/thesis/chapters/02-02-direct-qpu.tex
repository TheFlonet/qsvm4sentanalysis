\chapter{Using the QPU Directly}

The use of purely quantum solvers provided by D-Wave necessitates two main steps before a problem can be submitted to the QPU:

\begin{enumerate}
    \item Conversion of the problem into QUBO form;
    \item Transformation into an equivalent problem compatible with the QPU.
\end{enumerate}

As discussed in Section \ref{sec:dwaveconversion}, the former can be performed automatically using the libraries provided by D-Wave, which convert a problem expressed as an objective function and constraints (CSP) into an equivalent QUBO problem, i.e., $x^TQx$, as outlined in Section \ref{sec:AQC}.

The latter is related to minor embedding, which involves transforming the problem into an equivalent form that respects the qubit structure of the QPU.

The operations necessary to convert a CSP into a QUBO form can be executed in linear time. Therefore, if it were possible to perform minor embedding without requiring excessive computational resources or time, the use of the QPU without leveraging the hybrid component would present itself as a valid methodology for solving problems through adiabatic quantum computing.

The following sections will thus focus on analyzing the minor embedding algorithm, examining what has been implemented by D-Wave and the intrinsic complexity of the problem.

\section{Minor Embedding Algorithm}

\begin{displayquote}
    Given two arbitrary graphs $G$ and $H$, $G$ is called a minor of $H$ if $G$ is isomorphic to a graph that can be formed from $H$ by a series of the following operations: edge contraction, edge or vertex deletion.
\end{displayquote}

The definition provided introduces the concept of a minor graph, which is fundamental to understanding the applications of minor embedding. Two graphs are said to be isomorphic if there exists a bijective function between the vertices of the first graph and those of the second.

$G$ is the smaller graph and must be isomorphic to a transformation of $H$ based on three operations:
\begin{itemize}
    \item \emph{Edge deletion}: Involves removing an edge from graph $H$;
    \item \emph{Vertex deletion}: Involves removing a vertex from graph $H$. Together with edge deletion, this operation allows for the removal of redundant information;
    \item \emph{Edge contraction}: Allows for ``collapsing'' two nodes of $H$ into a new node, whose edges are the union of the edges of the two original nodes.
\end{itemize}

These three operations allow for the reduction of the size of $H$. If applying an appropriate sequence of these operations yields $G$, then $G$ is a minor of $H$.

Conceptually, the search for minor embedding can be viewed as a constraint satisfaction problem where:
\begin{enumerate}
    \item The goal is to minimize the number of nodes used by the mapping function $\phi: Vertex(G) \to 2^{Vertex(H)}$;
    \item Subject to the constraints:
    \begin{itemize}
        \item $\forall x\in Vertex(G)$, the subgraph induced by $\phi(x)$ in $H$ is connected;
        \item $\phi(x)$ and $\phi(y)$ are disjoint for every $x \neq y$ in $V(G)$;
        \item If $x$ and $y$ are adjacent in $G$, then there exists at least one edge between $\phi(x)$ and $\phi(y)$ in $H$.
    \end{itemize}
\end{enumerate}

In general, determining whether $G$ is a minor of $H$ is an NP-Complete problem. 
Sections \ref{sec:mepoly} and \ref{sec:menopoly} will analyze some notable cases of the algorithm, while Section \ref{sec:medwave} will briefly present the heuristic approach used by D-Wave to mitigate the complexity of execution.

\subsection{Polynomial Time Algorithms}\label{sec:mepoly}

In \cite{MEPoly}, Robertson and Seymour demonstrated that polynomial-time algorithms are possible for certain specific cases. 
In particular, their work focuses on the case where $G$ is a constant and the only variable input is the graph $H$. 
In this scenario, the proposed algorithm generates a solution in $O(n^3)$ (where $n$ is the number of vertices of $G$). 
This result was later improved, reaching a complexity of $O(n^2)$ in \cite{MEPoly2}.

By further restricting the domain to planar graphs \cite{MEPoly3}, it is possible to determine if $H$ is a minor of the input graph $G$ in linear time, $O(n)$.

\paragraph{Intractability of Polynomial Time Cases} The algorithms presented belong to the complexity class $P$ and can be solved in polynomial time. 
However, the complexity of these proposals is hidden in the multiplicative constant, which is disregarded in \emph{Big-O notation}. 
This constant is super polynomially related to the size of $H$.

Such a high coefficient makes these procedures \emph{galactic algorithms}, which means that, despite their polynomial nature, they are not practically usable in real-world contexts.

\subsection{Non-Polynomial Cases}\label{sec:menopoly}

The case addressed for solving the minor embedding required by the D-Wave QPU is the opposite of what was previously described.

The fixed data is the graph $H$, the larger graph, and $G$ is provided as input. 
The search for minor embedding proceeds by finding a sequence of steps that use the inverse operations of those used in minor searching (i.e., adding edges, vertices or expanding edges) to transform $G$ into $H$.

In this case, no polynomial-time algorithms exist for solving the problem, and \cite{MENP} demonstrates that the problem belongs to the NP-Complete family.

\paragraph{NP-Completeness} The article shows that the search for embedding on a Chimera graph \cite{QPU} reduces to the search for Hamiltonian cycles, a problem known as NP-complete.

Additionally, the extension from the Chimera graph to the Pegasus graph, used in current QPUs, and to the Zephyr graph \cite{QPU2}, a next-generation architecture currently available only experimentally, is demonstrated.

\subsection{Heuristic Search}\label{sec:medwave}

The described situation presents two incompatible drives:
\begin{itemize}
    \item On one hand, the need to compute the embedding of a graph to solve problems via QPU;
    \item On the other hand, the complexity of the algorithm prevents efficient search.
\end{itemize}

To reconcile these two realities, D-Wave proposes the use of a heuristic algorithm \cite{MEdwave}. 
This approach does not guarantee to find the best embedding or, in general, any embedding, and it does not attempt to prove the non-existence of an embedding in case of failure. 
Relaxing these conditions allows for faster search, making minor embedding feasible.

The algorithm works by attempting to create subgraphs that represent the embedding from a node to its neighbours. 
When a direct connection is not possible due to a lack of edges, a path of duplicate nodes (often referred to as a ``chain'') is constructed. 
Once embeddings for the subgraphs are built, the results are aggregated to form the embedding for the original graph.

The heuristic approach proposed by D-Wave is expected to allow for better scalability, making it feasible to apply the algorithm to graphs with hundreds of vertices.
