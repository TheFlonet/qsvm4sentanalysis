\chapter{QUBO Splitting Algorithm}

Following the theoretical discussion on the feasibility of the algebraic partitioning method in Section \ref{sec:prop}, this chapter provides an account of its implementation. 
Chapter \ref{sec:qsplitres} will present the results obtained from testing the procedures outlined.

\section{QUBO Utility Class}

Thus far, QUBO problems have been presented and analyzed in matrix form or as the equivalent produced equation. 
While matrices can represent these problems, the coefficient matrix $Q$ is often sparse, i.e. it contains many zero values relative to the total number of matrix cells.

As an upper triangular matrix, the maximum number of non-zero values is $n(n+1)/2$, where $n$ is the dimension of the $Q$ matrix. 
This implies, by definition, at least $n(n-1)/2$ zero values. Since QUBO problem information must be transmitted between different computers for processing, D-Wave has changed the representation format to eliminate redundant information.

To achieve this, instead of matrices, \textsc{HashMap}s are used, where the key is the pair representing the position in the matrix $(\text{row}, \text{col})$, and the value corresponds to the matrix coefficient at that cell. 
In this way, all zero values are ``discarded'', representing only the relevant information that characterizes the problem.

To operate effectively, it is necessary to maintain a dual representation of the QUBO problem: 
\begin{enumerate} 
	\item A matrix form for performing algebraic operations; 
	\item A minimal representation for transmitting the problem to D-Wave quantum solvers. 
\end{enumerate}

For this reason, a support class \texttt{QUBO} was developed to manage the consistency between the two representations automatically. 
The \texttt{QUBO} class is responsible for: 
\begin{itemize} 
	\item Maintaining a copy of the matrix representation; 
	\item Maintaining a copy of the compact representation; 
	\item Storing a set of solutions for the problem, if provided; 
	\item Keeping track of the variables associated with the rows and col\-umns of the matrix. 
    This additional information is crucial because, during decomposition, the symbolic names of variables could be lost, leading to meaningless assignments.
\end{itemize}

The available methods are responsible for:
\begin{itemize} 
	\item Converting the problem from one representation to the other; 
	\item Verifying whether the matrix is upper triangular; if not, it is converted using the LU algorithm\cite{LU}.
\end{itemize}

\section{\texttt{QSplitSampler} Implementation}

The main points of the implementation are outlined below; the complete code for \texttt{QSplitSampler} is available on GitHub\footnote{\url{https://github.com/TheFlonet/qsvm4sentanalysis/tree/main/subqubo}}.

\subsection{Main Method}

\texttt{QSplitSampler} distinguishes the execution of the main block into two categories: 
\begin{itemize} 
	\item Small-scale problems, or generally manageable-sized problems; 
	\item Problems that require partitioning. 
\end{itemize}

In the first case, the algorithm uses the QPU to solve QUBO instances where the problem size is less than \texttt{CUT\_DIM}, the cut-off size that distinguishes a manageable problem from one that cannot be addressed directly.

In the second case, the QUBO problem is partitioned using the \texttt{split\_problem} method, presented in Section \ref{sec:split}. 
Once the solutions are computed, they are aggregated using \texttt{aggregate\_solutions}, Section \ref{sec:aggr}.

\begin{python}
def QSplitSampler(qubo: QUBO, dim: int) -> QUBO:
    if dim <= CUT_DIM:
        res = SAMPLER.sample_qubo(qubo.qubo_dict, num_reads=10)
        qubo.solutions = res[min(res['energy'])]
        return qubo

    sub_problems = split_problem(qubo, dim)
    for i, q in enumerate(sub_problems):
        sub_problems[i] = QSplitSampler(q, dim // 2)
    return aggregate_solutions(sub_problems, qubo)
\end{python}

\subsection{Split Method}\label{sec:split}

The partitioning methodology follows the approach described in Section \ref{sec:prop}, where the matrix describing the QUBO problem is divided into four parts, with only three being returned, as one is zero by definition and does not contribute to the solution.

The order in which the new subproblems are returned is as follows: 
\begin{itemize} 
	\item The $\operatorname{UL}$ problem, corresponding to the top-left subproblem, it operates on the first half of the optimization variables; 
	\item The $\operatorname{UR}$ problem, the top-right sub-matrix portion, operating on both partitions of the variables; 
	\item The $\operatorname{BR}$ problem, the bottom-right sub-matrix portion, operates on the second half of the optimization variables. 
\end{itemize}

Although all matrix portions are converted to be upper triangular, the $\operatorname{UR}$ partition is, by definition, not a QUBO problem. 
This is because it operates on both partitions of the optimization variables, meaning $X^T \neq X$.

The compact representation required by D-Wave allows the solver to determine the problem dimensions automatically. 
Therefore, the problem solved in this case does not take the form shown in Equation \ref{eq:ur} but the one shown in Equation \ref{eq:realur}.

\begin{equation}
    \begin{bmatrix}
        x_1 & x_2 & x_3 & x_4 & x_5 & x_6
    \end{bmatrix}
    \begin{bmatrix}
        0 & 0 & 0 & q_{14}' & q_{15}' & q_{16}' \\
        0 & 0 & 0 & 0 & q_{25}' & q_{26}' \\
        0 & 0 & 0 & 0 & 0 & q_{36}' \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0 \\
        0 & 0 & 0 & 0 & 0 & 0
    \end{bmatrix}
    \begin{bmatrix}
        x_1 \\
        x_2 \\
        x_3 \\
        x_4 \\
        x_5 \\
        x_6
    \end{bmatrix}
    \label{eq:realur}
\end{equation}

That is, the subproblem is "embedded" in a zero matrix with dimensions equal to those of the original problem. 
This operation negates the dimensionality reduction of the QUBO problem; however, the underlying graph representing the problem remains sufficiently small to allow its resolution like the other two sub-matrices.

\subsection{Aggregation Method}\label{sec:aggr}

Once the subproblems are solved, the results must be aggregated to provide a complete solution to the problem.
The aggregation procedure involves the following steps: 
\begin{enumerate} 
	\item Combine the results of the $\operatorname{UL}$ and $\operatorname{BR}$ subproblems. Since these subproblems operate on different partitions of the variables, their union consists of concatenating the two partial assignments. 
    All possible configurations are considered by performing the Cartesian product between the two sets of elements. 
    The complete set of solutions obtained in this way is called $S_1$.
	\item For each possible assignment in $S_1$, extract the most similar assignment produced by $\operatorname{UR}$. 
    \item For each pair of assignments $\langle S_1,\operatorname{UR}\rangle$, mark the conflicting values. 
	\item Resolve the conflicts by extracting a new QUBO subproblem. This step is detailed in Section \ref{sec:qsearch}. 
	\item Keep only the $k$ best distinct solutions. This guarantees a manageable number of assignments to handle.
\end{enumerate}

\subsection{Quantum Local Search}\label{sec:qsearch}

Conflicting assignments can be resolved using various search methodologies, including: 
\begin{enumerate} 
	\item Brute-force resolution; 
	\item Local search techniques; 
	\item Extraction of a new QUBO problem. 
\end{enumerate}

The brute-force strategy was initially implemented, but for non-trivial problems, the number of assignments to test led to intractable issues.

Using local search techniques might be promising, but it would go against the principle underlying the development of \texttt{QSplitSampler}, which is to maximize the use of the QPU.

For these reasons, the most reasonable option was to assess the feasibility of using the QPU to resolve conflicting assignments.

\begin{python}
def local_search(df: pd.DataFrame, qubo: QUBO) -> pd.DataFrame:
    for i, row in df.iterrows():
        no_energy = row.drop('energy')

        nans = no_energy[np.isnan(no_energy)]
        qubo_nans = defaultdict(int)
        for row_idx in nans.index:
            for col_idx in nans.index:
                val = qubo.qubo_dict.get((row_idx, col_idx), 0)
                qubo_nans[(row_idx, col_idx)] = val
        nans_sol = SAMPLER.sample_qubo(qubo_nans, num_reads=10)
        nans_sol = nans_sol.to_pandas_dataframe()
                           .sort_values(by='energy', 
                                        ascending=True).iloc[0]
        df.loc[i, nans.index] = nans_sol.drop('energy')
        df.loc[i, 'energy'] += nans_sol['energy']

    return df
\end{python}

The underlying idea of the proposed search mechanism is to extract a subproblem, focusing on the rows and columns associated with the conflicting variables. 
Once extracted and converted, the subproblem can be resolved again on the QPU.

For example, consider the following partial assignment:

\begin{equation*}
    \begin{bmatrix}
        0 & x_2 & 1 & 1 & 0 & x_6
    \end{bmatrix}
    \begin{bmatrix}
        q_{11} & q_{12} & q_{13} & q_{14} & q_{15} & q_{16} \\
        0 & q_{22} & q_{23} & q_{24} & q_{25} & q_{26} \\
        0 & 0 & q_{33} & q_{34} & q_{35} & q_{36} \\
        0 & 0 & 0 & q_{44} & q_{45} & q_{46} \\
        0 & 0 & 0 & 0 & q_{55} & q_{56} \\
        0 & 0 & 0 & 0 & 0 & q_{66}
    \end{bmatrix}
    \begin{bmatrix}
        0 \\
        x_2 \\
        1 \\
        1 \\
        0 \\
        x_6
    \end{bmatrix}
\end{equation*}

From this, we extract the following subproblem:

\begin{equation*}
    \begin{bmatrix}
        x_2 & x_6
    \end{bmatrix}
    \begin{bmatrix}
        q_{22} & q_{26} \\
        0 & q_{66}
    \end{bmatrix}
    \begin{bmatrix}
        x_2 \\
        x_6
    \end{bmatrix}
\end{equation*}

In this case, the extracted subproblem still consists of an upper triangular matrix. 
However, if it were not, it is possible to transform the subproblem to bring it back to the standard QUBO formulation.

Unlike the method discussed in Section \ref{sec:split}, this search approach does not guarantee a specific size for the resulting problem. 
Experimentally, the number of variables with conflicting assignments remained small enough to allow resolution via the QPU.